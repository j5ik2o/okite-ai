# パッケージ設計原則

## 目次

- [凝集度と結合度](#凝集度と結合度)
  - [高凝集（High Cohesion）](#高凝集high-cohesion)
  - [低結合（Low Coupling）](#低結合low-coupling)
- [パッケージ原則（Robert C. Martin）](#パッケージ原則robert-c-martin)
  - [REP: 再利用とリリースの等価原則](#rep-再利用とリリースの等価原則)
  - [CCP: 共通閉鎖原則](#ccp-共通閉鎖原則)
  - [CRP: 共通再利用原則](#crp-共通再利用原則)
  - [ADP: 非循環依存原則](#adp-非循環依存原則)
  - [SDP: 安定依存原則](#sdp-安定依存原則)
  - [SAP: 安定抽象原則](#sap-安定抽象原則)
- [MECE 分割](#mece-分割)
- [Chunk Up / Chunk Down](#chunk-up--chunk-down)

## 凝集度と結合度

### 高凝集（High Cohesion）
パッケージ内の要素は強く関連し、単一の目的に向かって協調するべき。

**高凝集の指標:**
- すべての型/関数が1つのドメイン概念に結び付く
- 1つの要素の変更が同一パッケージ内の他要素変更を伴う
- パッケージを「〜のためのもの」と一文で説明でき、"and" が不要

**低凝集の指標:**
- 無関係なユーティリティが混在している
- 要素間の依存が共有されていない
- パッケージ説明に複数の無関係な概念が必要

### 低結合（Low Coupling）
パッケージ間の依存は最小であるべき。

**結合度の測り方:**
- 他パッケージからの import 数を数える
- パッケージ境界を跨ぐ共有データ構造を洗い出す
- 時間的結合（Aを呼んでからBが必須）を確認する

**結合を下げる方法:**
- 境界で明確なインターフェース（トレイト）を定義する
- 変化しやすい依存には依存性逆転を使う
- 状態共有よりもデータ受け渡しを優先する

## パッケージ原則（Robert C. Martin）

### REP: 再利用とリリースの等価原則
再利用の粒度はリリースの粒度に等しい。

→ 同じバージョンでリリースするなら、同じパッケージにまとめる。

### CCP: 共通閉鎖原則
一緒に変更されるクラスは同じ場所に置く。

→ 技術層ではなく「変更理由」でまとめる。

**例:**
```
# 悪い例: 技術層で分割
handlers/
services/
repositories/

# 良い例: ドメイン境界で分割
user_management/
  handler.rs
  service.rs
  repository.rs
```

### CRP: 共通再利用原則
一緒に使われるクラスは同じ場所に置く。

→ 使わないものへの依存を強制しない。

**違反例:**
```rust
// user.rs - メール検証に依存させてしまう例
pub struct User { /* ... */ }
pub fn validate_email(s: &str) -> bool { /* ... */ }  // 無関係
```

### ADP: 非循環依存原則
依存グラフに循環があってはならない。

**検出:** A が B を import し、B が A を import している（直接/間接）場合は循環。

**解決策:**
1. 共有型を新しいパッケージへ抽出する
2. 依存性逆転（トレイト）を使う
3. 本当に同一責務ならパッケージを統合する

### SDP: 安定依存原則
依存は安定側に向ける。

**安定度 = (求心結合) / (求心結合 + 遠心結合)**

- 求心結合（Afferent）: このパッケージに依存する数
- 遠心結合（Efferent）: このパッケージが依存する数

安定なパッケージ（依存される数が多い）は、不安定なパッケージ（依存する数が多い）に依存しない。

### SAP: 安定抽象原則
安定なパッケージは抽象的に、不安定なパッケージは具体的に。

→ コア/ドメインはトレイトを定義し、境界側が実装する。

## MECE 分割

### 定義
- **Mutually Exclusive**: 重複がない
- **Collectively Exhaustive**: 漏れがない

### パッケージへの適用

責務をグルーピングする際:

1. 各責務は必ず1つのパッケージに割り当てる
2. 未割り当ての責務を残さない
3. テスト: 「Xはどこに置く？」に対して答えが1つだけある

### よくある MECE 違反

| 違反 | 例 | 修正 |
| --- | --- | --- |
| 重複 | `utils` にドメイン要素が混在 | 適切なドメインパッケージへ移動 |
| 抜け | エラー型の置き場所が散在/不明 | 専用 `error` モジュールを作成 or 利用箇所へ同居 |
| 曖昧 | 「User は `auth` か `users` か？」 | ドメイン境界を明確化し片方に統一 |

## Chunk Up / Chunk Down

### Chunk Down（分解）
抽象から具体へ。

**問い:**
- 構成要素は何か
- 手順は何か
- 具体的に何が含まれるか

**適用例:**
- 「このモジュールはユーザー管理」→ 具体的な操作は？（作成、削除、更新、認証、認可）

### Chunk Up（抽象化）
具体から抽象へ。

**問い:**
- これは何の例か
- 共通するテーマは何か
- まとめると何の目的か

**適用例:**
- (create_user, delete_user, update_user) → 「ユーザーライフサイクル管理」

### 反復的な洗練

1. Chunk Down で原子要素を列挙する
2. Chunk Up で自然なグループを見つける
3. グループ名が付けづらければ、さらに分解して再グループ化する
