# パッケージ設計原則

## 目次

- [凝集度と結合度](#凝集度と結合度)
  - [凝集度の種類](#凝集度の種類)
  - [結合度の種類](#結合度の種類)
- [パッケージメトリクス](#パッケージメトリクス)
  - [Ca/Ce と不安定性 I](#cace-と不安定性-i)
  - [抽象度 A と Main Sequence](#抽象度-a-と-main-sequence)
  - [ミクロ指標（補助）](#ミクロ指標補助)
- [パッケージ原則（Robert C. Martin）](#パッケージ原則robert-c-martin)
  - [REP: 再利用とリリースの等価原則](#rep-再利用とリリースの等価原則)
  - [CCP: 共通閉鎖原則](#ccp-共通閉鎖原則)
  - [CRP: 共通再利用原則](#crp-共通再利用原則)
  - [ADP: 非循環依存原則](#adp-非循環依存原則)
  - [SDP: 安定依存原則](#sdp-安定依存原則)
  - [SAP: 安定抽象原則](#sap-安定抽象原則)
- [分割基準の比較](#分割基準の比較)
- [抽象の階段](#抽象の階段)
- [依存関係管理](#依存関係管理)
  - [境界の定義: 公開APIと内部実装の分離](#境界の定義-公開apiと内部実装の分離)
  - [依存性逆転・インターフェース・DI](#依存性逆転インターフェースdi)
  - [循環依存の検出と解消](#循環依存の検出と解消)
- [MECE 分割](#mece-分割)
- [Chunk Up / Chunk Down](#chunk-up--chunk-down)
- [テスト戦略](#テスト戦略)
- [バージョニングとリリース単位](#バージョニングとリリース単位)
- [評価チェックリスト](#評価チェックリスト)
- [リファクタリングトリガー](#リファクタリングトリガー)
- [パターン比較表](#パターン比較表)

## 凝集度と結合度

### 凝集度の種類

凝集度は「モジュール内部の要素が、どれだけ同じ目的に協調しているか」を表す。低→高の順:

| レベル | 名称 | 説明 | パッケージ設計への示唆 |
| --- | --- | --- | --- |
| 最低 | 偶発的凝集 | 無関係な要素の寄せ集め | `utils`, `common` が典型。即座に分解すべき |
| 低 | 論理的凝集 | 論理的に同種だが無関係（例: 全ログ処理） | 技術層分割で起きやすい |
| 低 | 時間的凝集 | 同時に実行されるだけ（例: 初期化処理） | 起動/終了フェーズに限定すべき |
| 中 | 手順的凝集 | 手順の順番で結びつく | フロー分割で起きやすい |
| 中 | 連絡的凝集 | 同一データを操作する | データモデル中心設計で発生 |
| 高 | 機能的凝集 | 単一の固有機能に集中 | **目指すべきレベル** |
| 最高 | 情報的凝集 | 同一概念/データ構造と関連操作がまとまる | OOPのカプセル化に近い。**最も推奨** |

**パッケージ設計で重要なのは**: 「このパッケージは何のために存在するか」が一文で答えられる状態（目的の単一性）。凝集の現代的解釈は「同一の変更理由」。

### 結合度の種類

結合度はモジュール間の関連性の強さ。低結合にするには「不要な関連をなくす」「必要な関連でも結び方を弱める」両面が必要。弱→強の順:

| レベル | 名称 | 説明 | 回避策 |
| --- | --- | --- | --- |
| 最弱 | データ結合 | 単純なデータ（プリミティブ）のみ受け渡し | 理想的 |
| 弱 | スタンプ結合 | 構造体の一部だけ使うが全体を渡す | 必要なフィールドだけ渡す |
| 中 | 制御結合 | フラグで他モジュールの振る舞いを制御 | Strategy パターンで分離 |
| 強 | 外部結合 | 外部フォーマット/プロトコルを共有 | アダプタで隔離 |
| 強 | 共通結合 | グローバルデータを共有 | DI/パラメータ渡しに変更 |
| 最強 | 内容結合 | 他モジュールの内部を直接参照 | 公開APIを経由させる |

**特に危険**: 内容結合（他モジュールの内部を直接参照）と共通結合（グローバルデータ共有）は、変更波及と理解困難を誘発する典型要因。

## パッケージメトリクス

設計を「良さげ」に語るだけでなく、観測可能にするための指標。

### Ca/Ce と不安定性 I

| 指標 | 定義 | 意味 |
| --- | --- | --- |
| Ca（Afferent Coupling） | 外部からこのパッケージに依存する数 | 「責任の重さ」。大きいほど変更の影響が大きい |
| Ce（Efferent Coupling） | このパッケージが外部に依存する数 | 「外部依存の多さ」。大きいほど外部変更の影響を受ける |
| I（Instability） | Ce / (Ca + Ce) | 0 = 最安定（依存されるが依存しない）、1 = 最不安定（依存するが依存されない） |

**解釈**:
- I = 0 に近いパッケージ: 多くから依存される安定した基盤。変更コストが高い → 抽象的であるべき
- I = 1 に近いパッケージ: 誰にも依存されない末端。変更コストが低い → 具体的でよい

### 抽象度 A と Main Sequence

| 指標 | 定義 | 意味 |
| --- | --- | --- |
| A（Abstractness） | 抽象型の数 / 全型の数 | 0 = 完全に具体、1 = 完全に抽象 |
| D（Main Sequenceからの距離） | \|A + I - 1\| | 0 に近いほどバランスが良い |

**Main Sequence**: A + I = 1 のライン。理想的にはこの線上にあるべき。

- **痛みのゾーン（Zone of Pain）**: A が低く I も低い = 安定しているのに具体的 → 変更が困難
- **無用のゾーン（Zone of Uselessness）**: A が高く I も高い = 不安定なのに抽象的 → 誰も使っていない

**注意**: メトリクスは不完全。単独で設計の良否を断定すべきではない。傾向の観測と比較に使う。

### ミクロ指標（補助）

パッケージ内部の品質を補助的に観測する:

| 指標 | 対象 | 意味 |
| --- | --- | --- |
| CBO（Coupling Between Objects） | クラス/型 | 他の型との結合数。高いほど変更の影響が広い |
| LCOM（Lack of Cohesion in Methods） | クラス/型 | メソッド間の凝集欠如。高いほど分割すべき兆候 |
| サイクロマティック複雑度 | 関数/メソッド | 制御フローの複雑さ。テスト数の見積もりに使える |

## パッケージ原則（Robert C. Martin）

### REP: 再利用とリリースの等価原則
再利用の粒度はリリースの粒度に等しい。

→ 同じバージョンでリリースするなら、同じパッケージにまとめる。

### CCP: 共通閉鎖原則
一緒に変更されるクラスは同じ場所に置く。

→ 技術層ではなく「変更理由」でまとめる。

**例:**
```
# 悪い例: 技術層で分割
handlers/
services/
repositories/

# 良い例: ドメイン境界で分割
user_management/
  handler.rs
  service.rs
  repository.rs
```

### CRP: 共通再利用原則
一緒に使われるクラスは同じ場所に置く。

→ 使わないものへの依存を強制しない。

**違反例:**
```rust
// user.rs - メール検証に依存させてしまう例
pub struct User { /* ... */ }
pub fn validate_email(s: &str) -> bool { /* ... */ }  // 無関係
```

### ADP: 非循環依存原則
依存グラフに循環があってはならない。

**検出:** A が B を import し、B が A を import している（直接/間接）場合は循環。

**解決策:**
1. 共有型を新しいパッケージへ抽出する
2. 依存性逆転（トレイト）を使う
3. 本当に同一責務ならパッケージを統合する

### SDP: 安定依存原則
依存は安定側に向ける。

**安定度 I = Ce / (Ca + Ce)**

- Ca（求心結合）: このパッケージに依存する数
- Ce（遠心結合）: このパッケージが依存する数

安定なパッケージ（依存される数が多い）は、不安定なパッケージ（依存する数が多い）に依存しない。

### SAP: 安定抽象原則
安定なパッケージは抽象的に、不安定なパッケージは具体的に。

→ コア/ドメインはトレイトを定義し、境界側が実装する。

## 分割基準の比較

サブパッケージ分割は「どの凝集軸を採用するか」の選択。代表的な軸:

| 分割軸 | 凝集の性質 | 利点 | リスク | 適するケース |
| --- | --- | --- | --- | --- |
| 機能（feature） | 変更が縦に閉じる | 関連コード近接、feature内変更閉鎖 | 共通化地獄 | チーム独立、vertical slicing |
| ドメイン（業務概念） | 情報的凝集 | モデル一貫性 | コンテキスト間翻訳コスト | Bounded Context、業務複雑 |
| レイヤ（技術層） | 技術責務分離 | 導入容易 | 1変更が全層に散る | 小規模、導入初期 |
| 責務（変更理由） | CCP準拠 | 変更局所化 | 初期分析コスト | 変更頻度が明確 |
| データモデル（DB） | データ近接 | CRUD明快 | ドメイン意図の漏洩 | データ中心アプリ |
| API境界（公開IF） | 表面積最小 | 内部変更自由度 | 過度な隠蔽 | ライブラリ設計 |

**選択の原則**: 変更理由（CCP）を第一に、次にドメイン概念で判断する。レイヤは補助軸として使う。

## 抽象の階段

パッケージ階層では「上位は理由/目的、下位は手段/詳細」という抽象勾配を守る。

```
ビジネス能力/目的（最上位の語彙）
  ↓
ユースケース（何を達成するか）
  ↓
ドメインモデル（不変条件・概念・ルール）
  ↓
インターフェース/ポート（外界との契約）
  ↓
実装詳細（DB, 外部API, UI, フレームワーク）
```

**依存の推奨方向**: 下位（具体・不安定）→ 上位（抽象・安定）。つまり実装詳細がポートに依存し、ポートがドメインに依存する。

- **チャンクアップ（抽象化）**: 複数のクラス/関数を束ねて「何のための変更か？」へ寄せる
- **チャンクダウン（具体化）**: 境界の内側で「どんなルール・データ・アルゴリズムか？」へ落とす（ただし外へ漏らさない）

## 依存関係管理

### 境界の定義: 公開APIと内部実装の分離

低結合を守る最短ルートは「境界を越えて見える"表面積"を小さくする」こと。

- パッケージが外部へ公開するのは **ファサード（入口）＋最小の契約型（DTO/Interface）** に限定する
- 内部は自由に変更できるようにする（情報隠蔽の実務的実現）
- 単一コードベースでも、コンパイラや仕組みを使って境界を強制する

### 依存性逆転・インターフェース・DI

「下位の詳細が上位の方針に従う」には依存性逆転（DIP）が有効:

- **ファサード**: 外からの入口を1〜少数に固定し、内部構造を露出しない
- **インターフェース（ポート）**: 上位側に契約を置き、下位実装がそれを満たす
- **DI（依存性注入）**: 生成と利用を分け、依存方向を制御する

### 循環依存の検出と解消

循環依存は「パッケージ境界が実質的に崩壊したシグナル」として扱う。

**検出**: 静的解析・アーキテクチャテストで自動化する。

**解消の実務パターン**:

1. **依存性逆転**: 依存される側の抽象（Interface/Trait）を依存する側へ移し、実装は逆向きに差し込む
2. **共有抽出**: 相互参照している共通型/ロジックを第三のパッケージへ移動し、循環辺を切る
3. **統合**: 分離が不適切なら素直に統合する

```
悪い例（循環）:
  A → B → C → A

解消例（共有抽出）:
  A → shared
  B → shared
  C → shared
  （循環が消える）
```

## MECE 分割

### 定義
- **Mutually Exclusive**: 重複がない
- **Collectively Exhaustive**: 漏れがない

### パッケージへの適用

**MECEは「設計の目的」ではなく「網羅性チェックの補助」として使う。**

実装は横断的関心（ログ、認可、トランザクション）を避けられず、完全MECEは境界の薄さ（共通化しすぎ）を誘発する危険がある。8〜9割の網羅で十分。

責務をグルーピングする際のチェック:
1. 各責務は必ず1つのパッケージに割り当てる
2. 未割り当ての責務を残さない
3. テスト: 「Xはどこに置く？」に対して答えが1つだけある

### よくある MECE 違反

| 違反 | 例 | 修正 |
| --- | --- | --- |
| 重複 | `utils` にドメイン要素が混在 | 適切なドメインパッケージへ移動 |
| 抜け | エラー型の置き場所が散在/不明 | 専用 `error` モジュールを作成 or 利用箇所へ同居 |
| 曖昧 | 「User は `auth` か `users` か？」 | ドメイン境界を明確化し片方に統一 |

## Chunk Up / Chunk Down

### Chunk Down（分解）
抽象から具体へ。

**問い:**
- 構成要素は何か
- 手順は何か
- 具体的に何が含まれるか

**適用例:**
- 「このモジュールはユーザー管理」→ 具体的な操作は？（作成、削除、更新、認証、認可）

### Chunk Up（抽象化）
具体から抽象へ。

**問い:**
- これは何の例か
- 共通するテーマは何か
- まとめると何の目的か

**適用例:**
- (create_user, delete_user, update_user) → 「ユーザーライフサイクル管理」

### 反復的な洗練

1. Chunk Down で原子要素を列挙する
2. Chunk Up で自然なグループを見つける
3. グループ名が付けづらければ、さらに分解して再グループ化する

## テスト戦略

テストは境界に比例して設計する。テストピラミッドの考え方で、粒度の違うテストをバランスさせる。

### 境界とテスト種別の対応

| テスト種別 | 対象の境界 | 目的 | 本数の目安 |
| --- | --- | --- | --- |
| ユニットテスト | パッケージ内部 | 内部の振る舞い・凝集を守る | 多い |
| 統合テスト | パッケージ間 | 境界横断の依存が設計どおりか | 中程度 |
| 契約テスト（CDC） | 公開API境界 | 互換性（結合点）を守る | 少ない |

### 契約テスト（Consumer-Driven Contract）

提供側が消費側の期待（契約）を理解し、サービス進化をその契約中心に行うパターン。

- 公開APIを持つパッケージは、消費側が期待する振る舞いを契約テストで保証する
- 内部実装の変更は契約が守られている限り自由

## バージョニングとリリース単位

パッケージ境界 = 変更理由の境界（CCP）であることが、リリース管理に効く。

- **公開APIの範囲を定義**: どの型/関数/エンドポイントが "public" か
- **public変更はSemVer方針で管理**: 破壊的変更 = major、後方互換追加 = minor、バグ修正 = patch
- **internalは互換性保証しない**: 契約テスト対象外にするなど線引き

変更が同一パッケージに閉じていれば、再リリース範囲を局所化できる。

## 評価チェックリスト

パッケージ単位でのレビューに使う（Yesが多いほど高凝集・低結合）:

- [ ] 各パッケージの目的が一文で言える（何を提供し、何を隠すか）
- [ ] 境界を越える依存は、公開API（ファサード/ポート）を経由している
- [ ] パッケージ依存グラフが非循環である（ADP）
- [ ] 安定度の高い領域（多くから依存される）が十分抽象化されている（SAP）
- [ ] 変更理由がパッケージ境界で止まる（CCP）
- [ ] 境界のテスト（統合/契約）が公開APIの範囲と一致している

## リファクタリングトリガー

以下が観測されたら「分割/境界の見直し」を検討する:

| トリガー | 兆候 | 対応 |
| --- | --- | --- |
| CCP違反 | 変更が複数パッケージに散る | 変更理由で再グルーピング |
| Ce増大 | 外部依存が増え続ける | 依存性逆転、ファサード導入 |
| 循環依存 | パッケージサイクル発生 | 共有抽出 or 依存性逆転 |
| 複雑度上昇 | テスト計画が肥大化 | パッケージ分割 |
| I の逆転 | 安定パッケージが不安定に依存 | SDP/DIPに基づく修正 |

## パターン比較表

規模/ドメインが異なるケースでの分割方針比較:

| ケース | 分割方針 | 利点 | リスク | 凝集/結合の評価 |
| --- | --- | --- | --- | --- |
| 小規模ライブラリ | 公開API中心（小さなpublic + 内部隠蔽） | 契約明確、内部変更容易 | 公開API肥大化で結合急増 | 高凝集=publicが「何を提供するか」でまとまる。低結合=Ce管理 |
| 中規模モノリス（複数チーム） | feature別 + 各feature内に薄いレイヤ | 変更がfeature内に閉じやすい | 共通化地獄、境界テスト曖昧 | 凝集は機能/変更理由で強い。結合は契約（API/ポート）で制御 |
| 大規模業務（規制・監査あり） | Bounded Context + 契約（API/イベント） | チーム境界とモデル整合性の両立 | コンテキスト間翻訳/統合コスト | 凝集はコンテキスト内で最大化、結合は契約点に限定 |
