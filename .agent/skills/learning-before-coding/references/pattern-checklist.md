# コードタイプ別パターンチェックリスト

新しいコードを実装する前に既存パターンを分析するための詳細チェックリスト。

## クラスとモジュール

### 構造パターン
- [ ] インターフェース/プロトコルが別途定義されているか？
- [ ] 抽象基底クラスを使用しているか？
- [ ] 具象クラスのみか？
- [ ] Mixin/Traitの合成か？
- [ ] 関数型モジュールパターンか？

### 命名規約
- [ ] クラス名のプレフィックス（例：`Base*`、`Abstract*`）
- [ ] クラス名のサフィックス（例：`*Service`、`*Repository`、`*Handler`）
- [ ] ファイル名がクラス名と一致しているか？
- [ ] ファイル名のケーシング（PascalCase、snake_case、kebab-case）
- [ ] メソッド命名（camelCase、snake_case）
- [ ] プライベートメンバーのプレフィックス（`_`、`#`、なし）

### 依存性注入
- [ ] コンストラクタインジェクション
- [ ] プロパティインジェクション
- [ ] メソッドインジェクション
- [ ] DIコンテナ/フレームワーク使用
- [ ] 手動ワイヤリング
- [ ] Factoryパターン

## 関数

### 関数パターン
- [ ] 純粋関数が好まれているか？
- [ ] async/awaitかコールバックか？
- [ ] Promiseチェーンか？
- [ ] エラー戻り値か例外か？
- [ ] ガード節のスタイルは？

### パラメータパターン
- [ ] 複数パラメータにオプションオブジェクト？
- [ ] シグネチャでの分割代入？
- [ ] デフォルト値のアプローチ
- [ ] 必須と任意の順序

## エラー処理

### 例外パターン
- [ ] カスタム例外クラス？
- [ ] 単一の基底例外？
- [ ] 例外階層の深さ
- [ ] 例外命名（`*Error`、`*Exception`）

### Result/Eitherパターン
- [ ] Result型を使用？
- [ ] null可能にOptional/Maybe？
- [ ] エラーコードかエラーオブジェクトか？
- [ ] エラーメッセージのフォーマット

### リカバリーパターン
- [ ] リトライロジックの配置場所
- [ ] フォールバック戦略
- [ ] ロギングアプローチ

## テスト

### テスト構成
- [ ] コロケーション（ソースの横に`*.test.ts`）
- [ ] 別ディレクトリ（`__tests__/`、`tests/`）
- [ ] ミラー構造？

### テスト命名
- [ ] `test_*`プレフィックス
- [ ] `*_test`サフィックス
- [ ] `*.spec.*`命名
- [ ] describe/itスタイル

### テストパターン
- [ ] AAA（Arrange-Act-Assert）？
- [ ] Given-When-Then？
- [ ] テストフィクスチャのアプローチ
- [ ] モック/スタブの規約
- [ ] テストデータ用ファクトリ関数

## API/エンドポイント

### ルートパターン
- [ ] RESTful規約？
- [ ] ルートファイルの構成
- [ ] Controller/Handler構造
- [ ] ミドルウェアの使用

### リクエスト/レスポンス
- [ ] DTOクラス？
- [ ] バリデーションレイヤーの配置
- [ ] レスポンスエンベロープのフォーマット
- [ ] エラーレスポンスの構造

## 設定

### 設定パターン
- [ ] 環境変数
- [ ] 設定ファイル（YAML、JSON、TOML）
- [ ] 設定クラス/オブジェクト構造
- [ ] シークレットの扱い

## ドキュメント

### コメントパターン
- [ ] JSDoc/docstringスタイル
- [ ] インラインコメントの頻度
- [ ] TODOフォーマット
- [ ] ライセンスヘッダー

### 型ドキュメント
- [ ] 全箇所に型アノテーション？
- [ ] 戦略的なアノテーションのみ？
- [ ] 戻り値型は常に指定？

## ファイル構成

### ディレクトリ構造
- [ ] 機能ベース（ドメイン別）
- [ ] レイヤーベース（controllers/、services/、repos/）
- [ ] ハイブリッドアプローチ

### モジュールエクスポート
- [ ] バレルファイル（index.ts）？
- [ ] 名前付きエクスポートのみ？
- [ ] デフォルトエクスポート？
- [ ] 再エクスポートパターン

## 言語固有

### TypeScript
- [ ] strictモード？
- [ ] Type vs Interfaceの優先
- [ ] Enum vs constオブジェクト
- [ ] anyの使用許容度

### Python
- [ ] 全箇所に型ヒント？
- [ ] dataclass vs 通常クラス
- [ ] __all__エクスポート
- [ ] 相対 vs 絶対インポート

### Go
- [ ] コンシューマパッケージにインターフェース？
- [ ] ポインタ vs 値レシーバ
- [ ] エラーラッピングスタイル
- [ ] パッケージ命名

### Rust
- [ ] Result<T, E>パターン
- [ ] エラー型の設計
- [ ] モジュール構成
- [ ] トレイト定義の配置場所

### Scala
- [ ] case class vs 通常クラス
- [ ] trait vs abstract class
- [ ] sealed trait/enum の使用
- [ ] implicit/given の使用パターン
- [ ] for内包表記 vs flatMap/map
- [ ] Either/Option/Try の使い分け
- [ ] コンパニオンオブジェクトの構成
- [ ] パッケージオブジェクトの使用
- [ ] 型クラスパターンの実装方式
- [ ] Effect型（IO、ZIO、Cats Effect）の選択
