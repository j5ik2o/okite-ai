---
name: spec-constraint-card
description: >-
  軽量仕様駆動開発のための制約カード作成スキル。ユーザーの意図を最小限の制約に凝縮し、
  仕様インフレーションを防ぐ。kiroのような重厚な仕様駆動ではなく、Planモードより構造的な
  「ちょうどいい仕様化」を実現する。制約カードは散文の仕様書ではなく、AIの解空間を絞る
  チェック可能な制約リスト。`.constraints/<name>.md`に保存しバージョン管理可能。
  トリガー：「制約カードを作って」「〜を実装したい」「〜を追加したい」「lightweight spec」
  「軽量仕様」「constraint card」「制約を定義したい」といった実装開始前の仕様化リクエストで起動。
  spec-done-checkスキルやspec-scope-guardスキルと組み合わせて使用する。
  kiroワークフロー（/kiro:spec-*）を使う場合はこのスキルは不要。
---

# 制約カード（Constraint Card）

散文の仕様書ではなく、最小限の制約で実装をガイドする。

## 核心原則

**AIに必要なのは解空間を絞る制約であり、人間を説得する散文ではない。**

| アプローチ | 成果物 | 行数 | 問題 |
|-----------|--------|------|------|
| 重厚SDD（kiro） | requirements.md + design.md + tasks.md | 200-500行 | 仕様インフレーション、本質的でないコード増加 |
| Planモード | 頭の中の計画 | 0行 | 検証不能、スコープ制御なし |
| **制約カード** | `.constraints/<name>.md` | **20-30行** | ちょうどいい |

## 制約カードの構造

YAMLフロントマター + 6セクション。制約・非目標・受入テストは各3-5項目以内、タスクは3-7項目。超えたら分割を検討する。

```markdown
---
status: active
---
## 意図
[1-2文で何を達成するか。WHYではなくWHATだけ]

## 制約 (MUST)
- [実装が満たすべき条件。チェック可能な形で書く]
- [最大5個]
- TDD: テストを先に書き、テストが通る最小限の実装を行う
- Codex設計レビュー: 実装前に Codex Architect で設計レビューを実施する
- Codexコードレビュー: 実装完了後に Codex Code Reviewer でレビューを実施する

## 非目標 (NOT)
- [明示的にやらないこと。スコープの外壁]
- [最大5個]

## タスク
- [ ] A-01: Codex設計レビュー実施・指摘対応
- [ ] A-02: [テスト作成（Red）]
- [ ] B-01: [実装（Green）]
- [ ] C-01: [リファクタ（Refactor）]
- [ ] D-01 (P): [3-7個。TDDサイクルに沿った順序で記述する]
- [ ] D-02 (P): Codexコードレビュー実施・指摘対応
(P)は並行作業可能

## 受入テスト
- [具体的な検証シナリオ。Given/When/Then or 箇条書き]
- [最大5個]

## 設計判断
- [型設計、API設計、ライブラリ選定、アーキテクチャ選択]
- [設計レビュー前に記述する。空のまま設計レビューに進まない]
```

### TDD（必須）

タスクは Red → Green → Refactor のサイクルに従う。

| フェーズ | やること | 確認 |
|---------|---------|------|
| **Red** | 受入テストに対応するテストコードを先に書く | テストが失敗すること |
| **Green** | テストが通る最小限の実装を書く | テストが成功すること |
| **Refactor** | 重複除去・命名改善など | テストが引き続き成功すること |

- テストなしの実装は制約違反とみなす
- 「テストの追加」を最後のタスクにしない（テストが先）

### Codex設計レビュー（実装前・必須）

制約カード作成後、TDD実装に入る前に Codex で **設計レビュー** を実施する。
設計の妥当性を実装前に検証することで、手戻りを防ぐ。

```
mcp__codex__codex({
  prompt: "以下の制約カードを設計レビューしてください。\n\n[制約カード内容]",
  "developer-instructions": "あなたは pragmatic minimalist のソフトウェアアーキテクトです。\n\nレビュー観点:\n- 型設計の妥当性（過剰設計・過少設計）\n- 既存アーキテクチャとの整合性\n- API の一貫性（命名・シグネチャ・エラー処理パターン）\n- YAGNI 違反（不要な抽象化・将来のための設計）\n- 参照実装（Pekko/protoactor-go）との乖離が妥当か\n\n出力形式:\n1. 判定: APPROVE / REQUEST_CHANGES\n2. 重大な指摘（あれば）\n3. 軽微な提案（あれば）\n4. 総評（1-2文）",
  sandbox: "read-only"
})
```

- APPROVE → TDD実装に進む
- REQUEST_CHANGES → 制約カードを修正して再レビュー

### Codexコードレビュー（実装後・必須）

TDD実装完了後、`done` に遷移する前に Codex で **コードレビュー** を実施する。

```
mcp__codex__codex({
  prompt: "以下の変更差分をコードレビューしてください。\n\n[git diff 出力]",
  "developer-instructions": "あなたはシニアコードレビュアーです。このコードを深夜2時のインシデント対応時に保守する前提でレビューしてください。\n\nレビュー観点:\n- 正しさ（ロジックバグ、エッジケース、off-by-one）\n- セキュリティ（OWASP Top 10、入力検証）\n- 既存パターンとの一貫性（命名規約、エラー処理、モジュール構造）\n- テストカバレッジの十分性（境界値、異常系）\n- パフォーマンス（不要なクローン、アロケーション）\n\nスタイルの指摘は不要（フォーマッタに任せる）。\n\n出力形式:\n1. 判定: APPROVE / REQUEST_CHANGES\n2. 重大な指摘（修正必須）\n3. 軽微な提案（任意）",
  sandbox: "read-only"
})
```

- APPROVE → spec-done-check へ
- REQUEST_CHANGES → コードを修正して再レビュー

#### 全体フロー

```
制約カード作成 → 設計の導出 → 設計レビュー → TDD実装 → コードレビュー → spec-done-check → done
                                 ↓ REQUEST_CHANGES        ↓ REQUEST_CHANGES
                              カード修正 → 再レビュー    コード修正 → 再レビュー
```

- 設計判断が空のまま設計レビューに進まない
- 設計レビュー APPROVE で初めて TDD 実装に着手可能
- コードレビュー APPROVE で初めて `done` に遷移可能
- 常に使えるSkillがないか検討すること

## ステータス管理

制約カードはYAMLフロントマターの `status` フィールドでライフサイクルを管理する。

| status | 意味 | 遷移条件 |
|--------|------|----------|
| `draft` | 作成中（制約が未確定） | 初回作成時（任意） |
| `active` | 実装対象 | ユーザー確認後（デフォルト） |
| `done` | 実装完了 | `/spec-done-check` が PASS |

- 作成時のデフォルトは `active`
- `done` への遷移条件: 設計レビュー APPROVE → TDD実装完了 → コードレビュー APPROVE → `/spec-done-check` が PASS
- `/spec-scope-guard` は `status: active` のカードのみを対象とする
- `done` のカードは検証対象外（再開する場合は手動で `active` に戻す）
- 設計レビュー・コードレビューの両方を経ずに `done` にしてはならない

## 引数

`$ARGUMENTS` でスキル名（ケバブケース）を受け取る。省略時はユーザーに確認する。

```
/spec-constraint-card jwt-authentication
→ .constraints/jwt-authentication.md を作成
```

## 手順

### 1. 意図の抽出

ユーザーの依頼から「何を達成するか」を1-2文に圧縮する。

```
❌ 「ユーザーがシステムにログインする際、JWTトークンを発行し、
     セキュリティ要件を満たしつつ、既存の認証基盤との後方互換性を...」
✅ 「JWT認証を追加する」
```

### 2. 既存コードの分析

実装前に既存コードを確認し、制約を導出する。

- 影響を受けるファイル・モジュールを特定
- 既存のインターフェース・契約を確認
- 破壊してはならない境界を見つける

### 3. 制約の絞り込み

**膨らませるのではなく削る。** 以下の質問で制約を絞る。

- この制約がなくても実装は失敗するか？ → NO なら削除
- この制約はテストで検証できるか？ → NO なら書き直す
- この制約は受入テストと重複していないか？ → YES なら統合

### 4. 非目標の明示

非目標はスコープガードの外壁になる。「やらないこと」を明示することで、
実装中の脱線を防ぐ。

### 5. タスクの定義

制約を達成するための実装ステップをチェックリストとして列挙する。

- **必須**: タスクセクションは省略してはならない
- 3-7個のチェックボックス形式
- 実装開始時に全て `[ ]`、完了したら `[x]` に更新する
- タスクは「Whatの分解」であり「Howの詳細」ではない
- **TDD順序**: テスト → 実装 → リファクタの順で記述する
- **Codex設計レビュー**: 最初のタスクとして「Codex設計レビュー実施・指摘対応」を必ず含める
- **Codexコードレビュー**: 最終タスクとして「Codexコードレビュー実施・指摘対応」を必ず含める

```
❌ 「auth/middleware.tsの42行目にif文を追加する」（実装詳細すぎる）
❌ テストが最後に来るタスク順序（テストは実装より先）
✅ 「認証ミドルウェアのテスト作成 → 認証ミドルウェアの実装」（TDD順序）
```

### 6. 受入テストの定義

受入テストは制約の具体化。テストとして実行可能な形で書く。

```
❌ 「認証が正しく動作すること」（検証不能）
✅ 「有効なJWTでGET /api/usersが200を返す」（検証可能）
```

### 7. 制約カードの保存

`.constraints/<name>.md` に保存する。ファイル名はケバブケース。

```bash
.constraints/
├── jwt-authentication.md
├── user-profile-api.md
└── notification-system.md
```

### 8. 設計の導出

制約カードの「設計判断」セクションを充実させる。要件（制約・受入テスト）から設計を導出する。

- 影響を受ける型・モジュールの特定
- API設計（メソッドシグネチャ、型パラメータ）
- 参照実装（Pekko/protoactor-go）との対応関係
- 既存パターンとの整合性確認

「設計判断」セクションが空の場合、設計レビューは意味をなさない。最低限の設計判断を記述すること。

### 9. Codex設計レビューの実施

制約カードの設計判断が出揃った段階で、TDD実装に入る前に Codex で設計レビューを行う。

```
手順:
1. 制約カード（意図・制約・設計判断）を Codex に渡す
2. 設計レビュー: mcp__codex__codex を Architect として呼び出す
   → REQUEST_CHANGES なら制約カードを修正して再レビュー
   → APPROVE なら TDD 実装に着手
```

### 10. 実装時のTDDサイクル

設計レビュー APPROVE 後、実装は以下の順序で進める。

1. **受入テストからテストコードを導出** — 受入テストの各項目に対応するテストを書く
2. **テストが失敗することを確認**（Red）
3. **テストが通る最小限の実装**（Green）
4. **リファクタ** — テストが通る状態を維持しつつ改善（Refactor）
5. **繰り返し** — 全受入テストがPassするまで1-4を繰り返す

### 11. Codexコードレビューの実施

TDD実装完了後、`spec-done-check` の前に Codex でコードレビューを行う。

```
手順:
1. git diff で変更差分を取得
2. コードレビュー: mcp__codex__codex を Code Reviewer として呼び出す
   → REQUEST_CHANGES なら修正して再レビュー
   → APPROVE → spec-done-check → status: done
```

ワークフロー全体:
```
制約カード作成 → 設計の導出 → 設計レビュー → TDD実装 → コードレビュー → spec-done-check → done
```

## 制約カードの例

```markdown
---
status: active
---
## 意図
ユーザー認証にJWTを追加する

## 制約 (MUST)
- 既存の認証インターフェースを破壊しない
- トークン有効期限は設定可能（デフォルト1h）
- 認証失敗時は401を返す
- TDD: テストを先に書き、テストが通る最小限の実装を行う
- Codex設計レビュー: 実装前に Codex Architect で設計レビューを実施する
- Codexコードレビュー: 実装完了後に Codex Code Reviewer でレビューを実施する

## 非目標 (NOT)
- OAuth2対応
- リフレッシュトークン
- セッション管理
- ソーシャルログイン

## タスク
- [ ] Codex設計レビュー実施・指摘対応
- [ ] 認証ミドルウェアのテスト作成（Red）
- [ ] 認証ミドルウェアの実装（Green）
- [ ] トークン生成・検証のテスト作成（Red）
- [ ] トークン生成・検証ロジックの実装（Green）
- [ ] リファクタ・重複除去（Refactor）
- [ ] Codexコードレビュー実施・指摘対応

## 受入テスト
- 有効なJWTでGET /api/usersが200を返す
- 期限切れJWTで401が返る
- 不正な署名のJWTで401が返る
- JWTなしでのアクセスで401が返る

## 設計判断
- ライブラリ: jsonwebtoken
- トークン格納: Authorizationヘッダー（Bearer）
```

### リファクタリングの例

```markdown
---
status: active
---
## 意図
ユーザーモジュールのパッケージ構造をドメイン用語ベースに再編する

## 制約 (MUST)
- 全テストがリファクタリング前後で同じ結果になる
- 公開APIのシグネチャを変更しない
- 1PR = 1モジュール移動（段階的に実施）
- TDD: テストを先に書き、テストが通る最小限の実装を行う
- Codex設計レビュー: 実装前に Codex Architect で設計レビューを実施する
- Codexコードレビュー: 実装完了後に Codex Code Reviewer でレビューを実施する

## 非目標 (NOT)
- ロジックの変更・最適化
- 新機能の追加
- テストの書き直し

## タスク
- [ ] Codex設計レビュー実施・指摘対応
- [ ] 移動対象モジュールの依存関係を調査
- [ ] 既存テストが全Passすることを確認（ベースライン）
- [ ] パッケージ構造の移動
- [ ] import文の更新
- [ ] テストの実行・既存テスト全Pass確認
- [ ] Codexコードレビュー実施・指摘対応

## 受入テスト
- 既存テストが全てPassする
- import文が新しいパッケージパスに更新されている
- 循環依存が発生していない
```

## アンチパターン

```
❌ 制約が10個以上 → 機能を分割する
❌ 「〜であるべき」「〜が望ましい」 → チェック可能な形に書き直す
❌ 背景・理由・代替案の議論 → 制約カードに書かない
❌ 実装詳細（「〜クラスを作る」） → 制約は What であり How ではない
❌ 非目標が空 → スコープが定義されていない
❌ テストが実装の後に来るタスク順序 → Red → Green → Refactor の順
❌ 設計レビューなしで TDD 実装に着手 → 設計レビューは実装前の必須ゲート
❌ コードレビューなしで done にする → コードレビューは実装後の必須ゲート
❌ 設計判断が空のまま設計レビューに進む → 要件から設計を導出してからレビュー
```

## 制約カード数の上限ガイド

- 制約5個以内、受入テスト5個以内を目標
- 超える場合は機能を分割し、制約カードを2枚にする
- 分割の基準: 独立してデプロイ/テストできるか

## 関連スキル

- **spec-done-check**: 制約カードに対する実装完了検証
- **spec-scope-guard**: 実装中のスコープ逸脱検出
