---
name: spec-constraint-card
description: >-
  軽量仕様駆動開発のための制約カード作成スキル。ユーザーの意図を最小限の制約に凝縮し、
  仕様インフレーションを防ぐ。kiroのような重厚な仕様駆動ではなく、Planモードより構造的な
  「ちょうどいい仕様化」を実現する。制約カードは散文の仕様書ではなく、AIの解空間を絞る
  チェック可能な制約リスト。`.constraints/<name>.md`に保存しバージョン管理可能。
  トリガー：「制約カードを作って」「〜を実装したい」「〜を追加したい」「lightweight spec」
  「軽量仕様」「constraint card」「制約を定義したい」といった実装開始前の仕様化リクエストで起動。
  spec-done-checkスキルやspec-scope-guardスキルと組み合わせて使用する。
  kiroワークフロー（/kiro:spec-*）を使う場合はこのスキルは不要。
---

# 制約カード（Constraint Card）

散文の仕様書ではなく、最小限の制約で実装をガイドする。

## 核心原則

**AIに必要なのは解空間を絞る制約であり、人間を説得する散文ではない。**

| アプローチ | 成果物 | 行数 | 問題 |
|-----------|--------|------|------|
| 重厚SDD（kiro） | requirements.md + design.md + tasks.md | 200-500行 | 仕様インフレーション、本質的でないコード増加 |
| Planモード | 頭の中の計画 | 0行 | 検証不能、スコープ制御なし |
| **制約カード** | `.constraints/<name>.md` | **20-30行** | ちょうどいい |

## 制約カードの構造

YAMLフロントマター + 6セクション。制約・非目標・受入テストは各3-5項目以内、タスクは3-7項目。超えたら分割を検討する。

```markdown
---
status: active
---
## 意図
[1-2文で何を達成するか。WHYではなくWHATだけ]

## 制約 (MUST)
- [実装が満たすべき条件。チェック可能な形で書く]
- [最大5個]

## 非目標 (NOT)
- [明示的にやらないこと。スコープの外壁]
- [最大5個]

## タスク
- [ ] [実装ステップ。完了したらチェックを付ける]
- [ ] [3-7個。進捗追跡のためのチェックリスト]

## 受入テスト
- [具体的な検証シナリオ。Given/When/Then or 箇条書き]
- [最大5個]

## 設計判断（任意）
- [ライブラリ選定、アーキテクチャ選択など決まっていれば]
```

## ステータス管理

制約カードはYAMLフロントマターの `status` フィールドでライフサイクルを管理する。

| status | 意味 | 遷移条件 |
|--------|------|----------|
| `draft` | 作成中（制約が未確定） | 初回作成時（任意） |
| `active` | 実装対象 | ユーザー確認後（デフォルト） |
| `done` | 実装完了 | `/spec-done-check` が PASS |

- 作成時のデフォルトは `active`
- `/spec-done-check` が PASS を返したとき、`status: done` に自動更新
- `/spec-scope-guard` は `status: active` のカードのみを対象とする
- `done` のカードは検証対象外（再開する場合は手動で `active` に戻す）

## 引数

`$ARGUMENTS` でスキル名（ケバブケース）を受け取る。省略時はユーザーに確認する。

```
/spec-constraint-card jwt-authentication
→ .constraints/jwt-authentication.md を作成
```

## 手順

### 1. 意図の抽出

ユーザーの依頼から「何を達成するか」を1-2文に圧縮する。

```
❌ 「ユーザーがシステムにログインする際、JWTトークンを発行し、
     セキュリティ要件を満たしつつ、既存の認証基盤との後方互換性を...」
✅ 「JWT認証を追加する」
```

### 2. 既存コードの分析

実装前に既存コードを確認し、制約を導出する。

- 影響を受けるファイル・モジュールを特定
- 既存のインターフェース・契約を確認
- 破壊してはならない境界を見つける

### 3. 制約の絞り込み

**膨らませるのではなく削る。** 以下の質問で制約を絞る。

- この制約がなくても実装は失敗するか？ → NO なら削除
- この制約はテストで検証できるか？ → NO なら書き直す
- この制約は受入テストと重複していないか？ → YES なら統合

### 4. 非目標の明示

非目標はスコープガードの外壁になる。「やらないこと」を明示することで、
実装中の脱線を防ぐ。

### 5. タスクの定義

制約を達成するための実装ステップをチェックリストとして列挙する。

- **必須**: タスクセクションは省略してはならない
- 3-7個のチェックボックス形式
- 実装開始時に全て `[ ]`、完了したら `[x]` に更新する
- タスクは「Whatの分解」であり「Howの詳細」ではない

```
❌ 「auth/middleware.tsの42行目にif文を追加する」（実装詳細すぎる）
✅ 「認証ミドルウェアの作成」（適切な粒度）
```

### 6. 受入テストの定義

受入テストは制約の具体化。テストとして実行可能な形で書く。

```
❌ 「認証が正しく動作すること」（検証不能）
✅ 「有効なJWTでGET /api/usersが200を返す」（検証可能）
```

### 7. 制約カードの保存

`.constraints/<name>.md` に保存する。ファイル名はケバブケース。

```bash
.constraints/
├── jwt-authentication.md
├── user-profile-api.md
└── notification-system.md
```

## 制約カードの例

```markdown
---
status: active
---
## 意図
ユーザー認証にJWTを追加する

## 制約 (MUST)
- 既存の認証インターフェースを破壊しない
- トークン有効期限は設定可能（デフォルト1h）
- 認証失敗時は401を返す

## 非目標 (NOT)
- OAuth2対応
- リフレッシュトークン
- セッション管理
- ソーシャルログイン

## タスク
- [ ] 認証ミドルウェアの作成
- [ ] トークン生成・検証ロジックの実装
- [ ] 既存エンドポイントへのミドルウェア適用
- [ ] エラーレスポンス（401）の実装
- [ ] テストの追加

## 受入テスト
- 有効なJWTでGET /api/usersが200を返す
- 期限切れJWTで401が返る
- 不正な署名のJWTで401が返る
- JWTなしでのアクセスで401が返る

## 設計判断
- ライブラリ: jsonwebtoken
- トークン格納: Authorizationヘッダー（Bearer）
```

### リファクタリングの例

```markdown
---
status: active
---
## 意図
ユーザーモジュールのパッケージ構造をドメイン用語ベースに再編する

## 制約 (MUST)
- 全テストがリファクタリング前後で同じ結果になる
- 公開APIのシグネチャを変更しない
- 1PR = 1モジュール移動（段階的に実施）

## 非目標 (NOT)
- ロジックの変更・最適化
- 新機能の追加
- テストの書き直し

## タスク
- [ ] 移動対象モジュールの依存関係を調査
- [ ] パッケージ構造の移動
- [ ] import文の更新
- [ ] テストの実行・確認

## 受入テスト
- 既存テストが全てPassする
- import文が新しいパッケージパスに更新されている
- 循環依存が発生していない
```

## アンチパターン

```
❌ 制約が10個以上 → 機能を分割する
❌ 「〜であるべき」「〜が望ましい」 → チェック可能な形に書き直す
❌ 背景・理由・代替案の議論 → 制約カードに書かない
❌ 実装詳細（「〜クラスを作る」） → 制約は What であり How ではない
❌ 非目標が空 → スコープが定義されていない
```

## 制約カード数の上限ガイド

- 制約5個以内、受入テスト5個以内を目標
- 超える場合は機能を分割し、制約カードを2枚にする
- 分割の基準: 独立してデプロイ/テストできるか

## 関連スキル

- **spec-done-check**: 制約カードに対する実装完了検証
- **spec-scope-guard**: 実装中のスコープ逸脱検出
